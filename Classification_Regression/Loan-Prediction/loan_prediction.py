# -*- coding: utf-8 -*-
"""Loan Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/shravan-18/Machine-Learning-Projects/blob/main/Classification_Regression/Loan%20Prediction/Loan%20Prediction.ipynb

# **Hackathon - Loan Prediction**

# **Install and Import Dependencies**
"""

# !pip install pycaret

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.impute import SimpleImputer
from pycaret.classification import *

from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import HistGradientBoostingClassifier
from catboost import CatBoostClassifier
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.neighbors import KNeighborsClassifier
import xgboost as xgb
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.ensemble import StackingClassifier

"""# **Data Exploration and Preprocessing**"""

train = pd.read_csv('/kaggle/input/loan-approval/train.csv')
test = pd.read_csv('/kaggle/input/loan-approval/test.csv')
train.head()

test.head()

test.isnull().sum()

train.isnull().sum()

train['Loan_Status'].replace({'Y':1, 'N':0}, inplace=True)

for i in train.columns:
    print(i, type(i), train[i].isnull().sum())

train['LoanAmount'].hist(bins=20)

def FillNA(df, cols_to_fill):
    for i in cols_to_fill:
        most_frequent_value = df[i].mode()[0]
        df[i].fillna(most_frequent_value, inplace=True)

    return df

train_cols_to_fill = ['Gender', 'Married', 'Dependents', 'Self_Employed',
                'Loan_Amount_Term', 'Credit_History']

test_cols_to_fill = ['Gender', 'Dependents', 'Self_Employed',
                'Loan_Amount_Term', 'Credit_History']

train = FillNA(train, train_cols_to_fill)
test = FillNA(test, test_cols_to_fill)

train['LoanAmount'].fillna(train['LoanAmount'].median(), inplace=True)
train['LoanAmount'] = np.log(train['LoanAmount'])

test['LoanAmount'].fillna(test['LoanAmount'].median(), inplace=True)
test['LoanAmount'] = np.log(test['LoanAmount'])

print(train.isnull().sum())
print()
print(test.isnull().sum())

x = ['Gender', 'Married', 'Dependents', 'Education',
       'Self_Employed', 'Credit_History', 'Property_Area']

for i in x:
    print(i, train[i].unique())

def OneHotEncode(df, cols_to_OHE):

    for i in cols_to_OHE:
        OneHotEncoded = pd.get_dummies(df[i], drop_first=True)
        OneHotEncoded = OneHotEncoded.astype(int)
        df = df.drop(i, axis=1)
        df = pd.concat([df, OneHotEncoded], axis=1)

    return df

train = OneHotEncode(train, x)
test = OneHotEncode(test, x)
train.head()

train.describe()

# c=1
# plt.figure(figsize=(12, 10))

# for i in train.columns[1:]:
#     ax = plt.subplot(7, 4,c)
#     c += 1
#     seaborn.boxplot(data = train, y=i)
# plt.tight_layout()

train = train.drop_duplicates()
test = test.drop_duplicates()

train = train.drop('Loan_ID', axis=1)
test_ID = test['Loan_ID']
test = test.drop('Loan_ID', axis=1)

train.columns

train.columns = train.columns.astype(str)
test.columns = test.columns.astype(str)

train.columns.values[6] = 'Married'
test.columns.values[5] = 'Married'

test.columns

train.columns

train['Total_Income'] = train['ApplicantIncome']+train['CoapplicantIncome']
test['Total_Income'] = test['ApplicantIncome']+test['CoapplicantIncome']

train['EMI'] = train['LoanAmount']/train['Loan_Amount_Term']
test['EMI'] = test['LoanAmount']/test['Loan_Amount_Term']

train['Balance'] = train['Total_Income']-(train['EMI']*1000)
test['Balance'] = test['Total_Income']-(test['CoapplicantIncome']*1000)

train.drop(['ApplicantIncome', 'CoapplicantIncome'], axis=1, inplace=True)
test.drop(['ApplicantIncome', 'CoapplicantIncome'], axis=1, inplace=True)
train.drop(['LoanAmount', 'Loan_Amount_Term'], axis=1, inplace=True)
test.drop(['LoanAmount', 'Loan_Amount_Term'], axis=1, inplace=True)

sns.distplot(train['Balance'])

train['Total_Income'] = np.log(train['Total_Income'])
test['Total_Income'] = np.log(train['Total_Income'])

#accuracy, precision, recall, f1

X = train.drop('Loan_Status', axis=1)
y = train['Loan_Status']

"""# **Stratified K fold split**"""

from sklearn.model_selection import StratifiedKFold

i=1
kf = StratifiedKFold(n_splits=5, shuffle=True)
for train_index, test_index in kf.split(X, y):
    X_train, X_test = X.iloc[train_index], X.iloc[test_index]
    y_train, y_test = y.iloc[train_index], y.iloc[test_index]

scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.fit_transform(X_test)

"""# **Make Predictions**"""

LR = LogisticRegression()
LR.fit(X_train, y_train)

y_pred = LR.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

test_preds = LR.predict(test)

pd.read_csv('/kaggle/input/loan-approval/sample_submission.csv').head()

sub = pd.DataFrame({'Loan_Status':test_preds})
sub = sub.replace({0:'N', 1:'Y'})
sub

sub = pd.concat([test_ID, sub], axis=1)
sub

sub.to_csv('/kaggle/working/submissions.csv')

DTC = DecisionTreeClassifier()
DTC.fit(X_train, y_train)

y_pred = DTC.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

RFC = RandomForestClassifier()
RFC.fit(X_train, y_train)

y_pred = RFC.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

KNN = KNeighborsClassifier()
KNN.fit(X_train, y_train)

y_pred = KNN.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

HGB = HistGradientBoostingClassifier()
HGB.fit(X_train, y_train)

y_pred = HGB.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

XGB = XGBClassifier()
XGB.fit(X_train, y_train)

y_pred = XGB.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

ETC = ExtraTreesClassifier()
ETC.fit(X_train, y_train)

y_pred = ETC.predict(X_test)

print(f'Accuracy: {accuracy_score(y_test, y_pred)}')

# # Initialize the classification setup
# classification_setup = setup(data=train, target='Loan_Status', train_size=0.8)

# # Compare different classification models
# best_model = compare_models()